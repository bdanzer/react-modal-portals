{"version":3,"sources":["components/spinner/spinner.component.jsx","components/modal/modal.component.jsx","components/button/button.component.jsx","components/image-item-modal/image-item-modal.component.jsx","components/image-item/image-item.component.jsx","components/image-collection/image-collection.component.jsx","App.js","serviceWorker.js","index.js"],"names":["Spinner","className","modalRoot","document","getElementById","Modal","props","el","createElement","classList","add","appendChild","this","removeChild","children","callBack","ReactDOM","createPortal","Fragment","onClick","React","Component","Button","forwardRef","otherProps","ref","ImageItemModal","state","editingMode","description","persistence","IMAGE_DESCRIPTION_KEY","image","id","closeButton","createRef","textarea","saveButton","window","localStorage","getItem","setState","modalOpen","setTimeout","current","focus","e","target","value","setItem","shiftKey","key","preventDefault","toggleModalHandler","toggleEditingMode","title","url","tabIndex","onKeyDown","handleCloseButtonKeyDown","bind","aria-label","alt","src","onChange","setEdits","handleKeyDown","maxlength","ImageItem","toggleModal","handleImageItemKeyDown","ImageCollection","images","map","App","isLoading","getImages","axios","get","response","data","Boolean","location","hostname","match","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c4ae2442.chunk.js","sourcesContent":["import React from 'react';\n\nimport './spinner.styles.scss';\n\nfunction Spinner() {\n    return (\n        <div className=\"loader\">Loading...</div>\n    );\n}\n\nexport default Spinner;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport PropTypes from 'prop-types'\n\nimport './modal.styles.scss';\n\nconst modalRoot = document.getElementById('modal');\n\nclass Modal extends React.Component {\n    constructor(props) {\n        super(props);\n        this.el = document.createElement('div');\n        this.el.classList.add('open');\n    }\n\n    componentDidMount() {\n        modalRoot.appendChild(this.el);\n    }\n\n    componentWillUnmount() {\n        modalRoot.removeChild(this.el);\n    }\n\n    render() {\n        const { children, callBack} = this.props;\n\n        return ReactDOM.createPortal(\n            <React.Fragment>\n                <div className=\"backdrop\" onClick={() => callBack()}></div>\n                {children}\n            </React.Fragment>, \n            this.el\n        );\n    }\n}\n\nModal.propTypes = {\n    callBack: PropTypes.func.isRequired\n};\n\nexport default Modal;","import React from 'react'\n\nimport './button.styles.scss';\n\nconst Button = React.forwardRef((otherProps, ref) => {\n    return (\n        <button ref={ref} {...otherProps}>\n            {otherProps.children}\n        </button>\n    );\n});\n\nexport default Button;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport Modal from '../modal/modal.component';\nimport Button from '../button/button.component';\n\nimport './image-item-modal.styles.scss';\n\nclass ImageItemModal extends React.Component {\n    state = {\n        editingMode: false,\n        description: 'Click Here To Add A Description'\n    }\n\n    constructor(props) {\n        super(props)\n\n        this.persistence = {\n            IMAGE_DESCRIPTION_KEY: `image-${props.image.id}-description` \n        };\n\n        this.closeButton = React.createRef();\n        this.textarea = React.createRef();\n        this.description = React.createRef();\n        this.saveButton = React.createRef();\n    }\n\n    componentDidMount() {\n        let description = window.localStorage.getItem(this.persistence.IMAGE_DESCRIPTION_KEY);\n\n        if (description) {\n            this.setState({description});\n        }\n\n        if (this.props.modalOpen) {\n            setTimeout(() => this.closeButton.current.focus());\n        }    \n    }\n\n    toggleEditingMode() {\n        this.setState({editingMode: !this.state.editingMode});\n    }\n\n    /**\n     * TODO: Could look into some user experience issues possibly, since\n     * it might not be ideal for things to save on modal close or as you \n     * type\n     */\n    setEdits(e) {\n        this.setState({description: e.target.value});\n\n        /**\n         * TODO: Maybe look into how to data model this better \n         * inside of a JSON object rather than individual keys\n         */\n        window.localStorage.setItem(this.persistence.IMAGE_DESCRIPTION_KEY, e.target.value);\n    }\n\n\n    /**\n     * TODO: Could clean up/compbine the keyDown functions\n     */\n    handleCloseButtonKeyDown(e) {\n        if (e.shiftKey && e.key === 'Tab' && this.state.editingMode) {\n            this.saveButton.current.focus();\n            return e.preventDefault();\n        }\n\n        if (e.shiftKey && e.key === 'Tab' && !this.state.editingMode) {\n            this.description.current.focus();\n            return e.preventDefault();\n        }\n\n        if (e.key === 'Enter') {\n            this.props.toggleModalHandler();\n            return e.preventDefault();\n        }\n    }\n\n    /**\n     * TODO: Could clean up/compbine the keyDown functions\n     */\n    handleKeyDown(e, target = 'description') {\n        if (e.key === 'Enter' && target === 'textarea') {\n            this.toggleEditingMode();\n            setTimeout(() => this.textarea.current.focus())\n            return e.preventDefault();\n        }\n\n        if (e.key === 'Enter' && target === 'button') {\n            this.toggleEditingMode();\n            setTimeout(() => this.description.current.focus())\n            return e.preventDefault();\n        }\n\n        if (e.key === 'Enter' && target === 'description') {\n            this.toggleEditingMode();\n            setTimeout(() => this.description.current.focus())\n            return e.preventDefault();\n        }\n\n        if (e.key === 'Tab' && !e.shiftKey && target !== 'description') {\n            this.closeButton.current.focus()\n            return e.preventDefault();\n        }\n    }\n\n    render() {\n        const {image: { title, url }, toggleModalHandler} = this.props;\n\n        return (\n            <Modal callBack={() => toggleModalHandler()}>\n                <Button \n                    ref={this.closeButton} \n                    tabIndex={0} \n                    className=\"close-modal\" \n                    onKeyDown={this.handleCloseButtonKeyDown.bind(this)} \n                    onClick={() => toggleModalHandler()}\n                    aria-label=\"Close Modal\">\n                    X\n                </Button>\n                <div className=\"image-item-modal-wrap\">\n                    <div className=\"image-wrapper\">\n                        <img alt={title} src={url}></img>\n                    </div>\n                    <div className=\"content-wrapper\">\n                        <h2>{title}</h2>\n                        {this.state.editingMode ? [\n                            <textarea\n                                key={1}\n                                tabIndex={0}\n                                aria-label=\"Editing Description\"\n                                ref={this.textarea}\n                                onChange={this.setEdits.bind(this)} \n                                value={this.state.description}\n                                onKeyDown={this.handleKeyDown.bind(this)}\n                                maxlength=\"140\"\n                            />,\n                            <Button \n                                key={2} \n                                ref={this.saveButton}\n                                onKeyDown={(e) => this.handleKeyDown(e, 'button')} \n                                onClick={this.toggleEditingMode.bind(this)}>\n                                Save Changes\n                            </Button>\n                        ] : \n                            <p \n                                ref={this.description} \n                                aria-label={`Hit Enter to start editing text: ${this.state.description}`}\n                                tabIndex={0} \n                                onClick={this.toggleEditingMode.bind(this)} \n                                onKeyDown={(e) => this.handleKeyDown(e, 'textarea')}>\n                                {this.state.description}\n                            </p>\n                        }\n                    </div>\n                </div>\n            </Modal>\n        )\n    }\n}\n\nImageItemModal.propTypes = {\n    image: PropTypes.object.isRequired,\n    toggleModalHandler: PropTypes.func.isRequired,\n    modalOpen: PropTypes.bool.isRequired\n};\n\nexport default ImageItemModal;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport ImageItemModal from '../image-item-modal/image-item-modal.component'\n\nimport './image-item.styles.scss';\n\nclass ImageItem extends React.Component {\n    state = {\n        modalOpen: false,\n    }\n\n    toggleModal() {\n        this.setState({\n            modalOpen: !this.state.modalOpen\n        })\n    }\n\n    handleImageItemKeyDown(e) {\n        if (e.key === 'Enter') {\n            this.toggleModal();\n            e.preventDefault();\n        }\n    }\n\n    render() {\n        const {image: { title, url }} = this.props\n\n        return (\n            <React.Fragment>\n                <div tabIndex={0} aria-label={title} className=\"image-item\" onClick={() => this.toggleModal()} onKeyDown={this.handleImageItemKeyDown.bind(this)}>\n                    <img alt={title} src={url}/>\n                </div>\n\n                 {/* \n                    TODO: Could probably move this to App.js \n                    and leverage react hooks instead of prop drilling \n                 */}\n                {this.state.modalOpen ? \n                    <ImageItemModal \n                        {...this.props} \n                        {...this.state} \n                        toggleModalHandler={this.toggleModal.bind(this)} \n                    />\n                : ''}\n            </React.Fragment>\n        );\n    }\n}\n\nImageItem.propTypes = {\n    image: PropTypes.object.isRequired\n};\n\nexport default ImageItem;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport ImageItem from '../image-item/image-item.component';\n\nimport './image-collection.styles.scss';\n\nfunction ImageCollection({ images }) {\n    return (\n        <div className=\"image-collection\">\n            {images.map(((image) => (\n                <ImageItem \n                    key={image.id}  \n                    image={image}\n                />\n            )))}\n        </div>\n    )\n}\n\nImageCollection.propTypes = {\n    images: PropTypes.array.isRequired\n};\n\nexport default ImageCollection","import React from 'react';\nimport axios from 'axios';\n\nimport Spinner from './components/spinner/spinner.component';\nimport ImageCollection from './components/image-collection/image-collection.component';\n\nimport './App.css';\n\nclass App extends React.Component {\n  state = {\n    isLoading: true,\n    images: null\n  };\n\n  componentDidMount() {\n    this.getImages();\n  }\n\n  /**\n   * TODO: Should implement a way to check \n   * for status codes in case of error\n   */\n  async getImages() {\n    let response = await axios.get('https://jsonplaceholder.typicode.com/photos?_start=0&_limit=25');\n    let data = response.data;\n\n    this.setState({\n      images: data,\n      isLoading: false\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        {(this.state.isLoading) ? \n          <Spinner/> \n          : (<ImageCollection images={this.state.images}/>)\n        }\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}